# Constants:
const uart_ep = 2

# LED0 is mapped to pin C9,C7
const led1_bank      = 2
const led2_bank      = 2
const led3_bank      = 5
const led_pin_maskC9  = $200
const led_pin_maskC7  = $80
const led_pin_maskF5 = $20

# some ASCII codes (used in the debug command interface)
const ASCII_ESC = 27

# Variables:
dim ticker
dim string(6)
dim strlen

dim connected
dim conn_handle
dim res
dim adc_value
dim adc_conv
dim temp
dim read_result
dim status_bytes(20)

dim button_states(2)    # state for each button 
const btn_state_pressed = 1
const btn_state_released = 2 
const btn_state_undefined = 0 

dim button_timestamps(8) # timestamp when button was pressed (2 * 4 bytes)
dim time_delta
dim num_notifications
dim notif_countdown
dim calllongpress

# helper function to print integer to UART
procedure print_int32(int32_value)

    call util_itoa(int32_value)(strlen, string(0:strlen))
    call endpoint_send(uart_ep, strlen, string(0:strlen))

end 


# Boot event listener - Generated when the module is powered up or reset
event system_boot(major, minor, patch, build, bootloader, hw)

    call endpoint_send(uart_ep, 20, "Boot. Build number: ") 
    call print_int32(build)
    call endpoint_send(uart_ep, 2, "\r\n") 
    num_notifications = 30 
    
    # Set advertisement interval to 100ms, use all three ADV channels
    call le_gap_set_adv_parameters(160,160,7)

    # Start Bluetooth LE advertisements and enable connections
    call le_gap_set_mode(2,2)
    
    # setup timer with 100ms interval
    call hardware_set_soft_timer(3276,0,0)
	
	# configure ADC reference voltage:
	call endpoint_send(uart_ep, 21, "ADC reference: VDD \r\n")
	call hardware_config_adc_reference(2)(res)
	
	#configure douplepress variable
	calllongpress = 0
	
end

event le_connection_opened(address, address_type, master, connection, bonding)

    call endpoint_send(uart_ep, 11, "Connected\r\n")
    connected = 1
    # make copy of connection handle for later use
    conn_handle = connection

end

# BLE connection disconnected event - Generated when a BLE connection is closed or lost
event le_connection_closed(reason, connection)

    call endpoint_send(uart_ep, 14, "Disconnected\r\n")
    connected = 0
    conn_handle = -1

    # Start Bluetooth LE advertisements and enable connections
    call le_gap_set_mode(2,2)
    
end


# Software timer event - generated when software timer runs out
event hardware_soft_timer(handle)

	# ADC test: 

	# read voltage at pin PC9
	call hardware_read_adc(2, 9)(res, adc_value)
	
	# convert raw ADC value to millivolts:
	adc_conv = adc_value * 3300 / 4096
	call print_int32(adc_conv)
	call endpoint_send(uart_ep, 2, "\r\n")
		
end

procedure button_press_short(button)

    if button = 0 then 
        call endpoint_send(uart_ep, 23, "Short press, Button 0\r\n")
    else 
        call endpoint_send(uart_ep, 23, "Short press, Button 1\r\n")
    end if 
	
end 


procedure button_press_long(button)

    if button = 0 then 
        call endpoint_send(uart_ep, 22, "Long press, Button 0\r\n")
        
    else 
        call endpoint_send(uart_ep, 22, "Long press, Button 1\r\n")
    end if 
	
end #procedure long press


procedure button_press_double()

	call endpoint_send(uart_ep, 23, "Both Buttons pressed\r\n")
	
end #procedure button_press_double


procedure button_pressed(button, timestamp)

    button_timestamps(button*4:4) = timestamp 
    button_states(button:1) = btn_state_pressed
    
end # procedure button_pressed


procedure button_released(button, timestamp)

    time_delta = timestamp - button_timestamps(button*4:4)
    button_states(button:1) = btn_state_released
    if calllongpress = 0 && button_states(0:1) = btn_state_released && button_states(1:1) = btn_state_released then
		if time_delta > 3000 then 
			# long press
			call button_press_long(button)
		else
			# short press
			call button_press_short(button)
		end if 
	else
		#both pressed
		if button_states(0:1) = btn_state_pressed || button_states(1:1) = btn_state_pressed then
			calllongpress = 1
		else
			call button_press_double()
			calllongpress = 0
		end if
	end if
    
end # procedure button_released


event hardware_interrupt(interrupts, timestamp)

    if (interrupts & led2_bank) = led2_bank then
        # read pin state to detect if this was falling or rising edge
        call hardware_read_gpio(led_pin_maskC7, led2_bank)(res, read_result)
        if read_result = led2_bank then
            call button_released(0, timestamp)
        else
            call button_pressed(0, timestamp)
        end if
    end if
    
    if (interrupts & led3_bank) = led3_bank then
        # read pin state to detect if this was falling or rising edge
        call hardware_read_gpio(led_pin_maskF5, led3_bank)(res, read_result)  
        if read_result = led3_bank then
            call button_released(1, timestamp)
        else
            call button_pressed(1, timestamp)
        end if
    end if
	
end


# End of BGScript