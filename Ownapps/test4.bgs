# Constants:
const uart_ep = 2

# BTN0 is mapped to pin F4
const btn0_bank      = 5
const btn0_pin_mask  = $10

# BTN1 is mapped to pin F5
const btn1_bank      = 5
const btn1_pin_mask  = $20


# some ASCII codes (used in the debug command interface)
const ASCII_ESC = 27

# Variables:
# Variables:
dim ticker
dim string(6)
dim strlen

dim connected
dim conn_handle
dim res
dim adc_value
dim adc_conv
dim temp
dim read_result
dim status_bytes(20)

dim button_states(2)    # state for each button 
const btn_state_pressed = 1
const btn_state_released = 2 
const btn_state_undefined = 0 

dim button_timestamps(8) # timestamp when button was pressed (2 * 4 bytes)
dim time_delta
dim num_notifications
dim notif_countdown
dim calllongpress



# this is a utility function to print passkey but we can use it also to print
# out ADC values...
procedure print_passkey(data)

    string(0:1) = (data / 100000) + (data / -1000000 * 10) + 48
    string(1:1) = (data / 10000) + (data / -100000 * 10) + 48
	string(2:1) = (data / 1000) + (data / -10000 * 10) + 48
	string(3:1) = (data / 100) + (data / -1000 * 10) + 48
	string(4:1) = (data / 10) + (data / -100 * 10) + 48
	string(5:1) = data + (data / 10 * -10) + 48
	
	call endpoint_send(uart_ep, 6, string(0:6))
	
end 

# helper function to print integer to UART
procedure print_int32(int32_value)

    call util_itoa(int32_value)(strlen, string(0:strlen))
    call endpoint_send(uart_ep, strlen, string(0:strlen))

end 


# Boot event listener - Generated when the module is powered up or reset
event system_boot(major, minor, patch, build, bootloader, hw)

    call endpoint_send(uart_ep, 20, "Boot. Build number: ") 
    call print_int32(build)
    call endpoint_send(uart_ep, 2, "\r\n")  

    
    num_notifications = 30 
    
    # Set advertisement interval to 100ms, use all three ADV channels
    call le_gap_set_adv_parameters(160,160,7)

    # Start Bluetooth LE advertisements and enable connections
    call le_gap_set_mode(2,2)
    
    # setup timer with 1000ms interval
    call hardware_set_soft_timer(32768,0,0)
        
end


event le_connection_opened(address, address_type, master, connection, bonding)

    call endpoint_send(uart_ep, 11, "Connected\r\n")
    connected = 1
    # make copy of connection handle for later use
    conn_handle = connection

end

# BLE connection disconnected event - Generated when a BLE connection is closed or lost
event le_connection_closed(reason, connection)

    call endpoint_send(uart_ep, 14, "Disconnected\r\n")
    connected = 0
    conn_handle = -1

    # Start Bluetooth LE advertisements and enable connections
    call le_gap_set_mode(2,2)
    
end


# This event indicates incoming data from an endpoint. Used here to implement simple debug
# command interface with the UART
event endpoint_data(endpoint,data_len, data_data)

    if endpoint != uart_ep then
        return
    end if
        
    if data_data(0:1) = ASCII_ESC then 
        call endpoint_send(uart_ep, 10, "--ESC---\r\n")
        # just a placeholder. you can enter any debug functionality here (e.g. disconnect if connection is active)
        return
    end if
    
end 


# capture writes from remote device. 

event gatt_server_attribute_value(connection,attribute,att_opcode,offset,value_len, value_data)
    
    if attribute = control_byte then
    
        num_notifications = value_data(0:1) 
        
        call endpoint_send(uart_ep, 25, "Num notifications set to ")
        call print_int32(num_notifications)
        call endpoint_send(uart_ep, 2, "\r\n")
    end if
end

# Software timer event - generated when software timer runs out
event hardware_soft_timer(handle)
	
	# ADC test: 

	# read voltage at pin PB11
	call hardware_read_adc(1, 11)(res, adc_value)
	
	# convert raw ADC value to millivolts:
	adc_conv = adc_value * 3300 / 4096
	

	call print_passkey(adc_conv)
	call endpoint_send(uart_ep, 2, "\r\n")
	
end


procedure button_press_short(button)

    if button = 0 then 
        call endpoint_send(uart_ep, 23, "Short press, Button 0\r\n")
    else 
        call endpoint_send(uart_ep, 23, "Short press, Button 1\r\n")
    end if 
	
end 


procedure button_press_long(button)

    if button = 0 then 
        call endpoint_send(uart_ep, 22, "Long press, Button 0\r\n")
        
    else 
        call endpoint_send(uart_ep, 22, "Long press, Button 1\r\n")
    end if 
	
end #procedure long press


procedure button_press_double()

	call endpoint_send(uart_ep, 23, "Both Buttons pressed\r\n")
	
end #procedure button_press_double


procedure button_pressed(button, timestamp)

    button_timestamps(button*4:4) = timestamp 
    button_states(button:1) = btn_state_pressed
    
end # procedure button_pressed


procedure button_released(button, timestamp)

    time_delta = timestamp - button_timestamps(button*4:4)
    button_states(button:1) = btn_state_released
    if calllongpress = 0 && button_states(0:1) = btn_state_released && button_states(1:1) = btn_state_released then
		if time_delta > 3000 then 
			# long press
			call button_press_long(button)
		else
			# short press
			call button_press_short(button)
		end if 
	else
		#both pressed
		if button_states(0:1) = btn_state_pressed || button_states(1:1) = btn_state_pressed then
			calllongpress = 1
		else
			call button_press_double()
			calllongpress = 0
		end if
	end if
    
end # procedure button_released


event hardware_interrupt(interrupts, timestamp)

    if (interrupts & btn0_pin_mask) = btn0_pin_mask then
        # read pin state to detect if this was falling or rising edge
        call hardware_read_gpio(btn0_bank, btn0_pin_mask)(res, read_result)
    
        if read_result = btn0_pin_mask then
            #call endpoint_send(uart_ep, 15, "BTN0 RELEASED\r\n")
            call button_released(0, timestamp)
        else
            #call endpoint_send(uart_ep, 14, "BTN0 PRESSED\r\n")
            call button_pressed(0, timestamp)
        end if
        
    end if
    
    if (interrupts & btn1_pin_mask) = btn1_pin_mask then
        # read pin state to detect if this was falling or rising edge
        call hardware_read_gpio(btn1_bank, btn1_pin_mask)(res, read_result)
    
        if read_result = btn1_pin_mask then
            #call endpoint_send(uart_ep, 15, "BTN1 RELEASED\r\n")
            call button_released(1, timestamp)
        else
            #call endpoint_send(uart_ep, 14, "BTN1 PRESSED\r\n")
            call button_pressed(1, timestamp)
        end if
        
    end if

end


# End of BGScript